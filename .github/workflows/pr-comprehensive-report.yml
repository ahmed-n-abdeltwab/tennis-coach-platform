name: PR - Comprehensive Report

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  actions: read
  checks: read

jobs:
  comprehensive-report:
    name: Generate Comprehensive PR Report
    runs-on: ubuntu-latest
    # Wait for CI to complete before running
    needs: []

    steps:
      - name: Get PR number
        id: pr
        run: |
          echo "number=${{ github.event.number }}" >> $GITHUB_OUTPUT

      - name: Checkout PR code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: "10"
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Set up Nx SHAs for affected detection
        uses: nrwl/nx-set-shas@v4

      - name: Get affected projects
        id: affected
        run: |
          set -e

          AFFECTED_APPS=$(pnpm exec nx show projects --affected --type app 2>/dev/null || true)
          AFFECTED_LIBS=$(pnpm exec nx show projects --affected --type lib 2>/dev/null || true)

          APP_COUNT=0
          LIB_COUNT=0

          if [ -n "$AFFECTED_APPS" ]; then
            APP_COUNT=$(echo "$AFFECTED_APPS" | grep -c . || echo 0)
          fi

          if [ -n "$AFFECTED_LIBS" ]; then
            LIB_COUNT=$(echo "$AFFECTED_LIBS" | grep -c . || echo 0)
          fi

          TOTAL_COUNT=$((APP_COUNT + LIB_COUNT))

          echo "total=$TOTAL_COUNT" >> $GITHUB_OUTPUT
          echo "apps=$APP_COUNT" >> $GITHUB_OUTPUT
          echo "libs=$LIB_COUNT" >> $GITHUB_OUTPUT

          # Save for later
          echo "$AFFECTED_APPS" > affected_apps.txt
          echo "$AFFECTED_LIBS" > affected_libs.txt

      - name: Wait for all CI checks to complete
        id: tests
        run: |
          echo "Waiting for CI checks to complete..."

          MAX_WAIT=1800  # 30 minutes max
          WAIT_INTERVAL=15
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Get all check runs for this commit
            RESPONSE=$(gh api repos/${{ github.repository }}/commits/${{ github.event.pull_request.head.sha }}/check-runs)

            # Get CI-related checks (exclude this workflow)
            CI_CHECKS=$(echo "$RESPONSE" | jq -r '.check_runs[] | select(.name != "Generate Comprehensive PR Report") | select(.name | test("Test -|Build|Lint|Security|Publish Test Results")) | "\(.name):\(.status):\(.conclusion)"')

            if [ -z "$CI_CHECKS" ]; then
              echo "No CI checks found yet, waiting..."
              sleep $WAIT_INTERVAL
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              continue
            fi

            echo "Current check status:"
            echo "$CI_CHECKS"

            # Check if all are completed
            PENDING=$(echo "$CI_CHECKS" | grep -c "in_progress\|queued" || true)

            if [ "$PENDING" -eq 0 ]; then
              echo "All CI checks completed!"

              # Check for failures
              FAILURES=$(echo "$CI_CHECKS" | grep -c ":failure" || true)

              if [ "$FAILURES" -gt 0 ]; then
                echo "all_passed=false" >> $GITHUB_OUTPUT
                echo "âŒ $FAILURES check(s) failed"
              else
                echo "all_passed=true" >> $GITHUB_OUTPUT
                echo "âœ… All checks passed"
              fi

              break
            fi

            echo "Waiting for $PENDING check(s) to complete..."
            sleep $WAIT_INTERVAL
            ELAPSED=$((ELAPSED + WAIT_INTERVAL))
          done

          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "Timeout waiting for CI checks"
            echo "all_passed=unknown" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Extract coverage thresholds from Jest configs
        id: thresholds
        run: |
          echo "Extracting coverage thresholds from Jest configs..."

          # Extract thresholds for each test type
          for test_type in unit integration e2e; do
            CONFIG_FILE="apps/api/jest.${test_type}.config.ts"

            if [ -f "$CONFIG_FILE" ]; then
              # Extract the branches threshold (they're all the same in the config)
              THRESHOLD=$(grep -A 5 "coverageThreshold:" "$CONFIG_FILE" | grep "branches:" | awk '{print $2}' | sed 's/,//' || echo "80")
              echo "${test_type}_threshold=$THRESHOLD" >> $GITHUB_OUTPUT
              echo "  ${test_type}: ${THRESHOLD}%"
            else
              echo "${test_type}_threshold=80" >> $GITHUB_OUTPUT
              echo "  ${test_type}: 80% (default)"
            fi
          done

          # Calculate thresholds for badges
          # Using unit test threshold as the baseline (most strict)
          UNIT_THRESHOLD=$(grep -A 5 "coverageThreshold:" "apps/api/jest.unit.config.ts" | grep "branches:" | awk '{print $2}' | sed 's/,//' || echo "80")

          EXCELLENT_THRESHOLD=$UNIT_THRESHOLD
          GOOD_THRESHOLD=$((UNIT_THRESHOLD - 20))

          if [ $GOOD_THRESHOLD -lt 50 ]; then
            GOOD_THRESHOLD=50
          fi

          echo "excellent_threshold=$EXCELLENT_THRESHOLD" >> $GITHUB_OUTPUT
          echo "good_threshold=$GOOD_THRESHOLD" >> $GITHUB_OUTPUT

          echo ""
          echo "Badge thresholds:"
          echo "  ðŸŸ¢ Excellent: â‰¥${EXCELLENT_THRESHOLD}%"
          echo "  ðŸŸ¡ Good: â‰¥${GOOD_THRESHOLD}%"
          echo "  ðŸ”´ Needs Work: <${GOOD_THRESHOLD}%"

      - name: Download coverage reports from CI
        id: download
        run: |
          echo "Downloading coverage reports from CI workflow..."
          echo "Commit SHA: ${{ github.event.pull_request.head.sha }}"

          # Find the CI workflow run for this commit
          echo "Searching for CI workflow runs..."
          gh api repos/${{ github.repository }}/actions/workflows/ci.yml/runs \
            --jq ".workflow_runs[] | select(.head_sha == \"${{ github.event.pull_request.head.sha }}\") | {id: .id, status: .status, conclusion: .conclusion}" \
            | head -5

          CI_RUN_ID=$(gh api repos/${{ github.repository }}/actions/workflows/ci.yml/runs \
            --jq ".workflow_runs[] | select(.head_sha == \"${{ github.event.pull_request.head.sha }}\") | .id" | head -1)

          if [ -n "$CI_RUN_ID" ]; then
            echo "Found CI run: $CI_RUN_ID"
            echo "ci_run_id=$CI_RUN_ID" >> $GITHUB_OUTPUT

            # Get job IDs for direct links to logs
            echo "Getting job IDs for test links..."
            gh api repos/${{ github.repository }}/actions/runs/$CI_RUN_ID/jobs \
              --jq '.jobs[] | select(.name | test("Test -")) | {name: .name, id: .id, conclusion: .conclusion}' \
              > job_info.json

            cat job_info.json

            # Extract job IDs
            UNIT_JOB_ID=$(jq -r 'select(.name | test("unit")) | .id' job_info.json | head -1)
            INTEGRATION_JOB_ID=$(jq -r 'select(.name | test("integration")) | .id' job_info.json | head -1)
            E2E_JOB_ID=$(jq -r 'select(.name | test("e2e")) | .id' job_info.json | head -1)

            echo "unit_job_id=$UNIT_JOB_ID" >> $GITHUB_OUTPUT
            echo "integration_job_id=$INTEGRATION_JOB_ID" >> $GITHUB_OUTPUT
            echo "e2e_job_id=$E2E_JOB_ID" >> $GITHUB_OUTPUT

            # List available artifacts
            echo "Available artifacts:"
            gh api repos/${{ github.repository }}/actions/runs/$CI_RUN_ID/artifacts --jq '.artifacts[] | {name: .name, size: .size_in_bytes}'

            # Download all test report artifacts
            for test_type in unit integration e2e; do
              echo ""
              echo "Downloading test-reports-${test_type}..."
              if gh run download $CI_RUN_ID --dir ./downloaded-reports --name "test-reports-${test_type}" 2>&1; then
                echo "  âœ… Downloaded test-reports-${test_type}"
              else
                echo "  âš ï¸ test-reports-${test_type} not available"
              fi
            done

            # List what we got
            echo ""
            echo "Downloaded files structure:"
            if [ -d "./downloaded-reports" ]; then
              find ./downloaded-reports -type f -exec echo "  {}" \;
            else
              echo "No files downloaded"
            fi
          else
            echo "âŒ No CI run found for this commit"
          fi
        env:
          GH_TOKEN: ${{ github.token }}
        continue-on-error: true

      - name: Generate comprehensive report
        id: report
        run: |
          set -e

          # Start report with summary
          echo "# ðŸš€ PR Analysis Report" > report.md
          echo "" >> report.md

          # Overall status badge
          if [ "${{ steps.tests.outputs.all_passed }}" == "true" ]; then
            echo "## âœ… All Checks Passed" >> report.md
          elif [ "${{ steps.tests.outputs.all_passed }}" == "unknown" ]; then
            echo "## â³ CI Checks Running" >> report.md
          else
            echo "## âš ï¸ Some Checks Failed" >> report.md
          fi
          echo "" >> report.md

          # Get dynamic thresholds
          EXCELLENT_THRESHOLD=${{ steps.thresholds.outputs.excellent_threshold }}
          GOOD_THRESHOLD=${{ steps.thresholds.outputs.good_threshold }}

          # Coverage Matrix (like Codecov/Nx Cloud)
          echo "### ðŸ“Š Coverage Matrix" >> report.md
          echo "" >> report.md
          echo "| Test Suite | Lines | Statements | Functions | Branches | Status |" >> report.md
          echo "|------------|-------|------------|-----------|----------|--------|" >> report.md

          OVERALL_STATUS="âœ…"
          CI_RUN_ID="${{ steps.download.outputs.ci_run_id }}"

          for test_type in unit integration e2e; do
            # Try multiple possible paths for downloaded artifacts
            COVERAGE_REPORT=""
            SUMMARY_FILE=""

            for base_path in "./downloaded-reports/test-reports" "./downloaded-reports"; do
              if [ -f "${base_path}/coverage-${test_type}.md" ]; then
                COVERAGE_REPORT="${base_path}/coverage-${test_type}.md"
              fi
              if [ -f "${base_path}/summary-${test_type}.md" ]; then
                SUMMARY_FILE="${base_path}/summary-${test_type}.md"
              fi
            done

            if [ -n "$COVERAGE_REPORT" ] && [ -f "$COVERAGE_REPORT" ]; then
              # Extract coverage percentages
              LINES=$(grep "Lines |" "$COVERAGE_REPORT" | head -1 | awk '{print $4}' || echo "N/A")
              STATEMENTS=$(grep "Statements |" "$COVERAGE_REPORT" | head -1 | awk '{print $4}' || echo "N/A")
              FUNCTIONS=$(grep "Functions |" "$COVERAGE_REPORT" | head -1 | awk '{print $4}' || echo "N/A")
              BRANCHES=$(grep "Branches |" "$COVERAGE_REPORT" | head -1 | awk '{print $4}' || echo "N/A")

              # Get badge with dynamic thresholds
              COV_NUM=$(echo "$LINES" | sed 's/%//')
              if [ "$COV_NUM" != "N/A" ]; then
                if (( $(echo "$COV_NUM >= $EXCELLENT_THRESHOLD" | bc -l 2>/dev/null || echo 0) )); then
                  BADGE="ðŸŸ¢ Excellent"
                elif (( $(echo "$COV_NUM >= $GOOD_THRESHOLD" | bc -l 2>/dev/null || echo 0) )); then
                  BADGE="ðŸŸ¡ Good"
                else
                  BADGE="ðŸ”´ Needs Work"
                fi
              else
                BADGE="âšª N/A"
              fi

              # Check if tests passed and add link
              if [ -n "$SUMMARY_FILE" ] && [ -f "$SUMMARY_FILE" ] && grep -q "âŒ Failed" "$SUMMARY_FILE"; then
                # Get job ID for this test type
                JOB_ID_VAR="${test_type}_job_id"
                JOB_ID="${{ steps.download.outputs[JOB_ID_VAR] }}"

                if [ -n "$JOB_ID" ] && [ -n "$CI_RUN_ID" ]; then
                  STATUS="[âŒ Failed](https://github.com/${{ github.repository }}/actions/runs/${CI_RUN_ID}/job/${JOB_ID})"
                else
                  STATUS="âŒ Failed"
                fi
                OVERALL_STATUS="âŒ"
              else
                STATUS="âœ… Passed"
              fi

              echo "| **${test_type^}** | $LINES | $STATEMENTS | $FUNCTIONS | $BRANCHES | $BADGE |" >> report.md
            else
              # No coverage report found - tests likely failed
              JOB_ID_VAR="${test_type}_job_id"
              JOB_ID=$(eval echo "\${{ steps.download.outputs.${JOB_ID_VAR} }}")

              if [ -n "$JOB_ID" ] && [ -n "$CI_RUN_ID" ]; then
                echo "| **${test_type^}** | N/A | N/A | N/A | N/A | [âŒ Failed](https://github.com/${{ github.repository }}/actions/runs/${CI_RUN_ID}/job/${JOB_ID}) |" >> report.md
              else
                echo "| **${test_type^}** | N/A | N/A | N/A | N/A | âŒ Failed |" >> report.md
              fi
              OVERALL_STATUS="âŒ"
            fi
          done

          echo "" >> report.md
          echo "> **Legend:** ðŸŸ¢ Excellent (â‰¥${EXCELLENT_THRESHOLD}%) â€¢ ðŸŸ¡ Good (â‰¥${GOOD_THRESHOLD}%) â€¢ ðŸ”´ Needs Work (<${GOOD_THRESHOLD}%)" >> report.md
          echo "" >> report.md

          # Test Results Summary
          echo "### ðŸ§ª Test Results" >> report.md
          echo "" >> report.md

          TOTAL_TESTS=0
          TOTAL_PASSED=0
          TOTAL_FAILED=0
          TOTAL_SKIPPED=0

          for test_type in unit integration e2e; do
            # Try multiple possible paths
            SUMMARY_FILE=""
            for base_path in "./downloaded-reports/test-reports" "./downloaded-reports"; do
              if [ -f "${base_path}/summary-${test_type}.md" ]; then
                SUMMARY_FILE="${base_path}/summary-${test_type}.md"
                break
              fi
            done

            if [ -n "$SUMMARY_FILE" ] && [ -f "$SUMMARY_FILE" ]; then
              # Extract test counts
              TESTS=$(grep "Total Tests" "$SUMMARY_FILE" | awk '{print $4}' | tr -d '|' || echo "0")
              PASSED=$(grep "âœ… Passed" "$SUMMARY_FILE" | awk '{print $4}' | tr -d '|' || echo "0")
              FAILED=$(grep "âŒ Failed" "$SUMMARY_FILE" | awk '{print $4}' | tr -d '|' || echo "0")
              SKIPPED=$(grep "â­ï¸ Skipped" "$SUMMARY_FILE" | awk '{print $4}' | tr -d '|' || echo "0")

              TOTAL_TESTS=$((TOTAL_TESTS + TESTS))
              TOTAL_PASSED=$((TOTAL_PASSED + PASSED))
              TOTAL_FAILED=$((TOTAL_FAILED + FAILED))
              TOTAL_SKIPPED=$((TOTAL_SKIPPED + SKIPPED))
            fi
          done

          if [ $TOTAL_TESTS -gt 0 ]; then
            echo "| Metric | Count |" >> report.md
            echo "|--------|-------|" >> report.md
            echo "| **Total Tests** | $TOTAL_TESTS |" >> report.md
            echo "| âœ… Passed | $TOTAL_PASSED |" >> report.md
            echo "| âŒ Failed | $TOTAL_FAILED |" >> report.md
            echo "| â­ï¸ Skipped | $TOTAL_SKIPPED |" >> report.md

            if [ $TOTAL_TESTS -gt 0 ]; then
              PASS_RATE=$(echo "scale=1; ($TOTAL_PASSED * 100) / $TOTAL_TESTS" | bc)
              echo "| **Pass Rate** | ${PASS_RATE}% |" >> report.md
            fi
          else
            echo "> âš ï¸ No test results available yet" >> report.md
          fi
          echo "" >> report.md

          # Affected Projects Summary
          TOTAL=${{ steps.affected.outputs.total }}
          if [ "$TOTAL" -gt 0 ]; then
            echo "### ðŸ“¦ Affected Projects" >> report.md
            echo "" >> report.md
            echo "ðŸŽ¯ **${TOTAL} project(s) affected** (${{ steps.affected.outputs.apps }} apps, ${{ steps.affected.outputs.libs }} libs)" >> report.md
            echo "" >> report.md
          fi

          # Collapsible sections for detailed information
          echo "<details>" >> report.md
          echo "<summary>ðŸ“‹ <b>Detailed Test & Coverage Reports</b></summary>" >> report.md
          echo "" >> report.md

          # Affected projects
          if [ "$TOTAL" -gt 0 ]; then
            echo "#### ðŸ“¦ Affected Projects" >> report.md
            echo "" >> report.md

            if [ ${{ steps.affected.outputs.apps }} -gt 0 ]; then
              echo "**Applications:**" >> report.md
              echo '```' >> report.md
              cat affected_apps.txt >> report.md
              echo '```' >> report.md
            fi

            if [ ${{ steps.affected.outputs.libs }} -gt 0 ]; then
              echo "**Libraries:**" >> report.md
              echo '```' >> report.md
              cat affected_libs.txt >> report.md
              echo '```' >> report.md
            fi
            echo "" >> report.md
          fi

          # Test summaries and coverage for each type
          DETAILS_FOUND=false
          for test_type in unit integration e2e; do
            # Try multiple possible paths
            SUMMARY_FILE=""
            COVERAGE_REPORT=""

            for base_path in "./downloaded-reports/test-reports" "./downloaded-reports"; do
              if [ -f "${base_path}/summary-${test_type}.md" ]; then
                SUMMARY_FILE="${base_path}/summary-${test_type}.md"
              fi
              if [ -f "${base_path}/coverage-${test_type}.md" ]; then
                COVERAGE_REPORT="${base_path}/coverage-${test_type}.md"
              fi
            done

            if [ -n "$SUMMARY_FILE" ] || [ -n "$COVERAGE_REPORT" ]; then
              DETAILS_FOUND=true
              echo "#### ðŸ§ª ${test_type^} Tests" >> report.md
              echo "" >> report.md

              # Get job ID for direct link
              JOB_ID_VAR="${test_type}_job_id"
              JOB_ID=$(eval echo "\${{ steps.download.outputs.${JOB_ID_VAR} }}")

              if [ -n "$SUMMARY_FILE" ] && [ -f "$SUMMARY_FILE" ]; then
                cat "$SUMMARY_FILE" >> report.md
                echo "" >> report.md
              else
                echo "> âš ï¸ No test results found" >> report.md
                echo "" >> report.md
              fi

              if [ -n "$COVERAGE_REPORT" ] && [ -f "$COVERAGE_REPORT" ]; then
                cat "$COVERAGE_REPORT" >> report.md
                echo "" >> report.md
              fi

              # Add direct link to this test suite's logs
              if [ -n "$JOB_ID" ] && [ -n "$CI_RUN_ID" ]; then
                echo "> ðŸ”— [View ${test_type} test logs](https://github.com/${{ github.repository }}/actions/runs/${CI_RUN_ID}/job/${JOB_ID})" >> report.md
                echo "" >> report.md
              fi
            fi
          done

          if [ "$DETAILS_FOUND" = false ]; then
            echo "> â„¹ï¸ Detailed reports will be available after CI completes" >> report.md
            echo "" >> report.md
          fi

          echo "</details>" >> report.md
          echo "" >> report.md

          # Failed tests section (if any)
          if [ $TOTAL_FAILED -gt 0 ]; then
            echo "### âŒ Failed Tests" >> report.md
            echo "" >> report.md

            for test_type in unit integration e2e; do
              # Try multiple possible paths
              SUMMARY_FILE=""
              for base_path in "./downloaded-reports/test-reports" "./downloaded-reports"; do
                if [ -f "${base_path}/summary-${test_type}.md" ]; then
                  SUMMARY_FILE="${base_path}/summary-${test_type}.md"
                  break
                fi
              done

              if [ -n "$SUMMARY_FILE" ] && [ -f "$SUMMARY_FILE" ] && grep -q "Failed Tests:" "$SUMMARY_FILE"; then
                echo "**${test_type^} Tests:**" >> report.md
                echo "" >> report.md
                # Extract failed test list
                sed -n '/\*\*Failed Tests:\*\*/,/^$/p' "$SUMMARY_FILE" | tail -n +2 >> report.md
                echo "" >> report.md

                # Add direct link to failed test logs
                JOB_ID_VAR="${test_type}_job_id"
                JOB_ID=$(eval echo "\${{ steps.download.outputs.${JOB_ID_VAR} }}")

                if [ -n "$JOB_ID" ] && [ -n "$CI_RUN_ID" ]; then
                  echo "ðŸ”— [View ${test_type} test logs](https://github.com/${{ github.repository }}/actions/runs/${CI_RUN_ID}/job/${JOB_ID})" >> report.md
                else
                  echo "ðŸ”— [View ${test_type} test logs](https://github.com/${{ github.repository }}/pull/${{ steps.pr.outputs.number }}/checks)" >> report.md
                fi
                echo "" >> report.md
              fi
            done
          fi

          # Build info
          echo "---" >> report.md
          echo "" >> report.md
          echo "## ðŸ—ï¸ Build Information" >> report.md
          echo "" >> report.md
          echo "- **PR**: #${{ steps.pr.outputs.number }}" >> report.md
          echo "- **Branch**: \`${{ github.head_ref }}\`" >> report.md
          echo "- **Commit**: \`${{ github.event.pull_request.head.sha }}\`" >> report.md
          echo "" >> report.md

          # Quick actions
          echo "## ðŸ”— Quick Actions" >> report.md
          echo "" >> report.md
          echo "- [View All Checks](https://github.com/${{ github.repository }}/pull/${{ steps.pr.outputs.number }}/checks)" >> report.md
          echo "- [View Changes](https://github.com/${{ github.repository }}/pull/${{ steps.pr.outputs.number }}/files)" >> report.md
          echo "- [View This Report Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> report.md
          echo "" >> report.md

          # Tips section
          echo "<details>" >> report.md
          echo "<summary>ðŸ’¡ <b>Tips for local development</b></summary>" >> report.md
          echo "" >> report.md
          echo "- See affected projects: \`pnpm exec nx show projects --affected\`" >> report.md
          echo "- Run affected tests: \`pnpm exec nx affected -t test\`" >> report.md
          echo "- View dependency graph: \`pnpm exec nx graph --affected\`" >> report.md
          echo "- Run with coverage: \`pnpm exec nx run api:test:unit -- --coverage\`" >> report.md
          echo "" >> report.md
          echo "</details>" >> report.md
          echo "" >> report.md

          # Footer
          echo "---" >> report.md
          echo "_ðŸ¤– Generated by PR Analysis Bot â€¢ [Powered by GitHub Actions](https://github.com/features/actions)_" >> report.md

          # Save to summary
          cat report.md > $GITHUB_STEP_SUMMARY

      - name: Comment PR
        if: steps.pr.outputs.number != ''
        uses: thollander/actions-comment-pull-request@v3
        with:
          file-path: report.md
          comment-tag: comprehensive-pr-report
          mode: recreate
          pr-number: ${{ steps.pr.outputs.number }}
